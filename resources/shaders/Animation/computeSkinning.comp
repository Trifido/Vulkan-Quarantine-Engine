#version 450

struct VertexIN {
	vec4 inPosition;
    vec4 inNormal;
    vec2 inTexCoord;
    vec4 inTangent;
};

struct VertexBonesIN {
    ivec4 inBoneIds; 
    vec4 inWeights;
};

struct VertexOUT{
	vec4 inPosition;
    vec4 inNormal;
    vec2 inTexCoord;
    vec4 inTangent;
};

const int MAX_BONES = 200;
const int MAX_BONE_INFLUENCE = 4;

layout(std430, binding = 0) buffer InputSSBO {
   VertexIN verticesIn[ ];
};

layout(std430, binding = 1) buffer InputBoneSSBO {
   VertexBonesIN verticesBonesIn[ ];
};

layout(std430, binding = 2) buffer OutputSSBO {
   VertexOUT verticesOut[ ];
};

layout(std430, set=0, binding=3) readonly buffer UniformAnimation
{
    mat4 finalBonesMatrices[];
} bones;

layout(std140, set = 0, binding = 4) uniform UniformVertexParam
{
	uint numVertices;
} uboVertexParam;

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main() 
{
    uint index = gl_GlobalInvocationID.x;

    if(index < uboVertexParam.numVertices)
    {
        ivec4 boneIds = verticesBonesIn[index].inBoneIds;
        vec4 weights = verticesBonesIn[index].inWeights;

        mat4 BoneTransform = bones.finalBonesMatrices[boneIds[0]] * weights[0] +
                             bones.finalBonesMatrices[boneIds[1]] * weights[1] +
                             bones.finalBonesMatrices[boneIds[2]] * weights[2] +
                             bones.finalBonesMatrices[boneIds[3]] * weights[3];

        mat3 matrix = mat3(BoneTransform);

        vec3 N = normalize(matrix * verticesIn[index].inNormal.xyz);
        vec3 T = normalize(matrix * verticesIn[index].inTangent.xyz);

        T = normalize(T - dot(T, N) * N);

        verticesOut[index].inPosition = BoneTransform * verticesIn[index].inPosition;
        verticesOut[index].inTexCoord = verticesIn[index].inTexCoord;
        verticesOut[index].inNormal  = vec4(N, 0.0);
        verticesOut[index].inTangent = vec4(T, 0.0);
    }
}