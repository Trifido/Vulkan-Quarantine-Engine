#version 460

#extension GL_ARB_shader_draw_parameters : enable
#extension GL_NV_mesh_shader: require

#extension GL_KHR_shader_subgroup_ballot: require

#define GPU_WARP_SIZE 32
#define GPU_GROUP_SIZE GPU_WARP_SIZE
#define CUT_OFF_FACTOR 0.75

layout(local_size_x = GPU_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

const float pi_half = 1.57079;

struct BoundingSphere
{
  vec3 center;
  float radius;
};

struct BoundingCone
{
  vec3 normal;
  float angle;
  vec4 position;
};

struct MeshletDescriptor
{
  BoundingSphere sphere;
  BoundingCone cone;
  uint dataOffset;
  uint meshIndex;
  uint vertexCount;
  uint triangleCount;
};

taskNV out Task
{
    uint meshletIndices[GPU_GROUP_SIZE];
} OUT;

layout(set = 0, binding = 0) uniform CameraUniform
{
	mat4 view;
	mat4 proj;
	mat4 viewproj;
    vec4 position;
    vec4 frustumPlanes[6];
} cameraData;

layout(set = 0, binding = 1) readonly buffer Meshlets
{
    MeshletDescriptor meshlets[];
};

layout(std430, push_constant) uniform PushConstants
{
    mat4 model;
} constants;

bool coneCull(vec3 center, float radius, vec3 cone_axis, float cone_cutoff)
{   
    return dot(center - cameraData.position.xyz, cone_axis) >= cone_cutoff * length(center - cameraData.position.xyz) + radius;
    // vec3 position = cameraData.position.xyz;
    // vec3 dir = normalize(center - position);
    // return dot(dir, cone_axis) >= cone_cutoff;
}

bool isSphereOutsideFrustum(vec4 sphere_center, float sphere_radius)
{                    
    vec4 sphere_view_center = cameraData.view * sphere_center;

    bool isInside = false;
    for(int i = 0; i < 6; i++)
    {
        isInside = isInside || (dot(cameraData.frustumPlanes[i].xyz, sphere_view_center.xyz) + cameraData.frustumPlanes[i].w < -sphere_radius);
    }
    return isInside;
}

void main()
{
    uint ti = gl_LocalInvocationID.x;    
    uint mgi = gl_WorkGroupID.x;
    uint mi = mgi * 32 + ti;

    OUT.meshletIndices[ti] = mi;

    if (ti == 0)
    {
        gl_TaskCountNV = 32;
    }
}