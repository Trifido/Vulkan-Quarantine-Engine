#version 450

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba16f, binding = 0) uniform image2D OutputImage;

#define STEP_COUNT 1000
const float PI = 3.14159265358;

// Unidades en Megametros (MM)
const float PlanetRadius = 6.360;
const float AtmosphereRadius = 6.460;

// Coeficientes de dispersión y absorción por MM
const vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1);
float  hDensityRayleigh = 8;

const float mieScatteringBase = 3.996;
const float mieAbsorptionBase = 4.4;
float hDensityMie  = 1.2;

const vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, 0.085);
float  ozoneCenterHeight = 25;
float  ozoneThickness   = 30;

bool findClosestIntersectionWithCircle(
    vec2 o, vec2 d, float R, out float t)
{
    float A = dot(d, d);
    float B = 2 * dot(o, d);
    float C = dot(o, o) - R * R;
    float delta = B * B - 4 * A * C;
    if(delta < 0)
        return false;
    t = (-B + (C <= 0 ? sqrt(delta) : -sqrt(delta))) / (2 * A);
    return (C <= 0) || (B <= 0);
}

vec3 getSigmaT(float h)
{
    vec3 rayleigh = rayleighScatteringBase * exp(-h / hDensityRayleigh);
    float mie = (mieScatteringBase + mieAbsorptionBase) * exp(-h / hDensityMie);
    vec3 ozone = ozoneAbsorptionBase * max(0.0, 1 - 0.5 * abs(h - ozoneCenterHeight) / ozoneThickness);
    return rayleigh + mie + ozone;
}

void main() 
{
    uvec3 threadIdx = gl_GlobalInvocationID;
    vec2 dimensions = vec2(imageSize(OutputImage));

    if (threadIdx.x >= dimensions.x || threadIdx.y >= dimensions.y)
        return;

    float theta = asin(mix(-1.0, 1.0, (threadIdx.y + 0.5) / dimensions.y));
    float h = mix(0.0, AtmosphereRadius - PlanetRadius, (threadIdx.x + 0.5) / dimensions.x);

    vec2 o = vec2(0, PlanetRadius + h);
    vec2 d = vec2(cos(theta), sin(theta));
    
    float t = 0;
    if(!findClosestIntersectionWithCircle(o, d, PlanetRadius, t))
        findClosestIntersectionWithCircle(o, d, AtmosphereRadius, t);

    vec2 end = o + t * d;

    vec3 sum;
    for(int i = 0; i < STEP_COUNT; ++i)
    {
        vec2 pi = mix(o, end, (i + 0.5) / STEP_COUNT);
        float hi = length(pi) - PlanetRadius;
        vec3 sigma = getSigmaT(hi);
        sum += sigma;
    }

    vec3 result = exp(-sum * (t / STEP_COUNT));
    
    imageStore(OutputImage, ivec2(threadIdx), vec4(result, 1.0));
}