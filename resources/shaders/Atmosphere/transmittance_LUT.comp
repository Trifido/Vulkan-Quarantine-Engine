#version 450

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba16f, binding = 0) uniform image2D OutputImage;

const float PI = 3.14159265358;

// Unidades en Megametros (MM)
const float groundRadiusMM = 6.360;
const float atmosphereRadiusMM = 6.460;

// Coeficientes de dispersi贸n y absorci贸n por MM
const vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1);
const float rayleighAbsorptionBase = 0.0;

const float mieScatteringBase = 3.996;
const float mieAbsorptionBase = 4.4;

const vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, .085);

const float sunTransmittanceSteps = 40.0;

//  Intersecci贸n Rayo-Esfera (Optimizado)
float rayIntersectSphere(vec3 ro, vec3 rd, float rad) {
    float b = dot(ro, rd);
    float c = dot(ro, ro) - rad*rad;
    if (c > 0.0f && b > 0.0) return -1.0;
    float discr = b*b - c;
    if (discr < 0.0) return -1.0;
    // Special case: inside sphere, use far discriminant
    if (discr > b*b) return (-b + sqrt(discr));
    return -b - sqrt(discr);
}

//  Obtiene los coeficientes de dispersi贸n y absorci贸n
void getScatteringValues(vec3 pos, out vec3 rayleighScattering, out float mieScattering, out vec3 extinction) {
    float altitudeKM = (length(pos) - groundRadiusMM) * 100.0;
    float rayleighDensity = exp(-altitudeKM / 8.0);
    float mieDensity = exp(-altitudeKM / 1.2);

    rayleighScattering = rayleighScatteringBase * rayleighDensity;
    float rayleighAbsorption = rayleighAbsorptionBase * rayleighDensity;

    mieScattering = mieScatteringBase * mieDensity;
    float mieAbsorption = mieAbsorptionBase * mieDensity;

    vec3 ozoneAbsorption = ozoneAbsorptionBase * max(0.0, 1.0 - abs(altitudeKM - 25.0) / 15.0);

    extinction = rayleighScattering + rayleighAbsorption + mieScattering + mieAbsorption + ozoneAbsorption;
}

//  Calcula la transmitancia de la luz solar a trav茅s de la atm贸sfera
vec3 getSunTransmittance(vec3 pos, vec3 sunDir) {
    if (rayIntersectSphere(pos, sunDir, groundRadiusMM) > 0.0) {
        return vec3(0.0); // El rayo golpea el suelo
    }

    float atmoDist = rayIntersectSphere(pos, sunDir, atmosphereRadiusMM);
    //if (atmoDist < 0.0) return vec3(1.0); // No hay intersecci贸n con la atm贸sfera

    float t = 0.0;
    vec3 transmittance = vec3(1.0);

    for (float i = 0.0; i < sunTransmittanceSteps; i += 1.0) {
        float newT = ((i + 0.3) / sunTransmittanceSteps) * atmoDist;
        float dt = newT - t;
        t = newT;

        vec3 newPos = pos + t * sunDir;

        vec3 rayleighScattering, extinction;
        float mieScattering;
        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

        transmittance *= exp(-dt * extinction);
    }
    return transmittance;
}

float safeacos(const float x) {
    return acos(clamp(x, -1.0, 1.0));
}

//  Shader principal
void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(texel) / vec2(imageSize(OutputImage));
    
    //  Convertimos UV en par谩metros f铆sicos
    float sunCosTheta = mix(-1.0, 1.0, uv.x); // De -1 (horizonte) a 1 (cenit)
    float sunTheta = safeacos(sunCosTheta);
    float heightMM = mix(groundRadiusMM, atmosphereRadiusMM, uv.y); // Altura en megametros
    
    vec3 pos = vec3(0.0, heightMM, 0.0); // Posici贸n en la atm贸sfera
    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta))); // Direcci贸n del sol

    //  Calculamos la transmitancia usando el m茅todo de integraci贸n
    vec3 transmittance = getSunTransmittance(pos, sunDir);
    
    //  Almacenar en la LUT
    imageStore(OutputImage, texel, vec4(transmittance, 1.0));
}