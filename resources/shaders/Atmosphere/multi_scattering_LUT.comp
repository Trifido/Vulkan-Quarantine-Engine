#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba16f) uniform image2D InputImage;
layout(binding = 1,rgba16f) uniform image2D OutputImage;

const float PI = 3.14159265358;

// Unidades en Megametros (MM)
const float PlanetRadius = 6.360;
const float AtmosphereRadius = 6.460;

// Coeficientes de dispersiÃ³n y absorciÃ³n por MM
const vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1);
const float mieScatteringBase = 3.996;
const float mieAbsorptionBase = 4.4;
const float asymmetryMie = 0.8;
float  hDensityRayleigh = 8;
float  hDensityMie  = 1.2;
const vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, 0.085);
float  ozoneCenterHeight = 25;
float  ozoneThickness   = 30;

float  sunIntensity = 10;
vec3 TerrainAlbedo = vec3(0.1);

//Ray marching parameters
int DIR_SAMPLE_COUNT     = 64;
int RAY_MARCH_STEP_COUNT = 256;

vec3 getTransmittance(float h, float theta)
{
    ivec2 textureSize = imageSize(InputImage);
    float u = h / (AtmosphereRadius - PlanetRadius);
    float v = 0.5 + 0.5 * sin(theta);
    ivec2 pixelCoords = ivec2(u * float(textureSize.x - 1), v * float(textureSize.y - 1));

    return imageLoad(InputImage, pixelCoords).rgb;
}

bool findClosestIntersectionWithSphere(vec3 o, vec3 d, const float R, out float t)
{
    float A = dot(d, d);
    float B = 2.0 * dot(o, d);
    float C = dot(o, o) - R * R;
    float delta = B * B - 4.0 * A * C;
    if(delta < 0.0)
        return false;
    t = (-B + (C <= 0.0 ? sqrt(delta) : -sqrt(delta))) / (2.0 * A);
    return (C <= 0.0) || (B <= 0.0);
}

bool hasIntersectionWithSphere(vec3 o, vec3 d, float R)
{
    float A = dot(d, d);
    float B = 2.0 * dot(o, d);
    float C = dot(o, o) - R * R;
    float delta = B * B - 4.0 * A * C;
    return (delta >= 0.0) && ((C <= 0.0) || (B <= 0.0));
}

vec3 evalPhaseFunction(float h, float u)
{
    vec3 sRayleigh = rayleighScatteringBase * exp(-h / hDensityRayleigh);
    float sMie = mieScatteringBase * exp(-h / hDensityMie);
    vec3 s = sRayleigh + sMie;

    float g = asymmetryMie, g2 = g * g, u2 = u * u;
    float pRayleigh = 3.0 / (16.0 * PI) * (1.0 + u2);

    float m = 1.0 + g2 - 2.0 * g * u;
    float pMie = 3.0 / (8.0 * PI) * (1.0 - g2) * (1.0 + u2) / ((2.0 + g2) * m * sqrt(m));

    vec3 result;
    result.x = s.x > 0.0 ? (pRayleigh * sRayleigh.x + pMie * sMie) / s.x : 0.0;
    result.y = s.y > 0.0 ? (pRayleigh * sRayleigh.y + pMie * sMie) / s.y : 0.0;
    result.z = s.z > 0.0 ? (pRayleigh * sRayleigh.z + pMie * sMie) / s.z : 0.0;
    return result;
}

void getSigmaST(float h, out vec3 sigmaS, out vec3 sigmaT)
{
    vec3 rayleigh = rayleighScatteringBase * exp(-h / hDensityRayleigh);

    float mieDensity = exp(-h / hDensityMie);
    float mieS = mieScatteringBase * mieDensity;
    float mieT = (mieScatteringBase + mieAbsorptionBase) * mieDensity;

    vec3 ozone = ozoneAbsorptionBase * max(0.0, 1.0 - 0.5 * abs(h - ozoneCenterHeight) / ozoneThickness);

    sigmaS = rayleigh + mieS;
    sigmaT = rayleigh + mieT + ozone;
}

vec3 uniformOnUnitSphere(float u1, float u2)
{
    float z   = 1.0 - 2.0 * u1;
    float r   = sqrt(max(0.0, 1.0 - z * z));
    float phi = 2.0 * PI * u2;
    return vec3(r * cos(phi), r * sin(phi), z);
}

void integrate(
    vec3 worldOri, vec3 worldDir, float sunTheta, vec3 toSunDir, out vec3 innerL2, out vec3 innerF)
{
    float u = dot(worldDir, toSunDir);

    float endT = 0.0;
    bool groundInct = findClosestIntersectionWithSphere(worldOri, worldDir, PlanetRadius, endT);
    if(!groundInct)
    {
        findClosestIntersectionWithSphere(worldOri, worldDir, AtmosphereRadius, endT);
    }

    float dt = endT / RAY_MARCH_STEP_COUNT;
    float halfDt = 0.5 * dt;
    float t = 0.0;

    vec3 sumSigmaT = vec3(0.0, 0.0, 0.0);

    vec3 sumL2 = vec3(0.0, 0.0, 0.0), sumF = vec3(0.0, 0.0, 0.0);
    for(int i = 0; i < RAY_MARCH_STEP_COUNT; ++i)
    {
        float midT = t + halfDt;
        t += dt;

        vec3 worldPos = worldOri + midT * worldDir;
        float h = length(worldPos) - PlanetRadius;

        vec3 sigmaS, sigmaT;
        getSigmaST(h, sigmaS, sigmaT);

        vec3 deltaSumSigmaT = dt * sigmaT;
        vec3 transmittance = exp(-sumSigmaT - 0.5 * deltaSumSigmaT);

        if(!hasIntersectionWithSphere(worldPos, toSunDir, PlanetRadius))
        {
            vec3 rho = evalPhaseFunction(h, u);
            vec3 sunTransmittance = getTransmittance(h, sunTheta);

            sumL2 += dt * transmittance * sunTransmittance * sigmaS * rho * sunIntensity;
        }

        sumF      += dt * transmittance * sigmaS;
        sumSigmaT += deltaSumSigmaT;
    }

    if(groundInct)
    {
        vec3 transmittance = exp(-sumSigmaT);
        vec3 sunTransmittance = getTransmittance(0.0, sunTheta);
        sumL2 += transmittance * sunTransmittance * max(0, toSunDir.y) * sunIntensity * (TerrainAlbedo / PI);
    }

    innerL2 = sumL2;
    innerF  = sumF;
}

vec2 hash(uint seed) {
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    
    float x = float(seed & 0xFFFF) / float(0xFFFF); // Aleatorio en [0,1]
    float y = float((seed >> 16) & 0xFFFF) / float(0xFFFF);
    
    return vec2(x, y);
}

vec3 ComputeM(float h, float sunTheta, uint baseSeed)
{
    vec3 worldOri = { 0.0, h + PlanetRadius, 0.0 };
    vec3 toSunDir = { cos(sunTheta), sin(sunTheta), 0.0 };

    vec3 sumL2 = vec3(0.0, 0.0, 0.0);
    vec3 sumF = vec3(0.0, 0.0, 0.0);
    for(int i = 0; i < DIR_SAMPLE_COUNT; ++i)
    {
        vec2 rawSample = hash(baseSeed + uint(i));
        vec3 worldDir = uniformOnUnitSphere(rawSample.x, rawSample.y);

        vec3 innerL2, innerF;
        integrate(worldOri, worldDir, sunTheta, toSunDir, innerL2, innerF);

        // phase function is canceled by pdf
        sumL2 += innerL2;
        sumF  += innerF;
    }

    vec3 l2 = sumL2 / DIR_SAMPLE_COUNT;
    vec3 f  = sumF  / DIR_SAMPLE_COUNT;
    return l2 / (1 - f);
}

void main() 
{
    uvec3 threadIdx = gl_GlobalInvocationID;
    vec2 dimensions = vec2(imageSize(OutputImage));

    if (threadIdx.x >= dimensions.x || threadIdx.y >= dimensions.y)
        return;
    
    uint seed = gl_GlobalInvocationID.x;
    float sinSunTheta = mix(-1.0, 1.0, (threadIdx.y + 0.5) / dimensions.y);
    float sunTheta = asin(sinSunTheta);

    float h = mix(0.0, AtmosphereRadius - PlanetRadius, (threadIdx.x + 0.5) / dimensions.x);

    // ðŸ”¸ Almacenar en la LUT
    imageStore(OutputImage, ivec2(threadIdx), vec4(ComputeM(h, sunTheta, seed), 1.0));
}