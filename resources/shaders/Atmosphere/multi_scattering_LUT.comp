#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba16f, binding = 0) uniform image2D InputImage;
layout(rgba16f, binding = 1) uniform image2D OutputImage;

const vec2 msLUTRes = vec2(32.0, 32.0);
const float PI = 3.14159265358;
const float mulScattSteps = 20.0;
const int sqrtSamples = 8;

const vec3 groundAlbedo = vec3(0.2);

// Unidades en Megametros (MM)
const float groundRadiusMM = 6.360;
const float atmosphereRadiusMM = 6.460;

// Coeficientes de dispersi贸n y absorci贸n por MM
const vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1);
const float rayleighAbsorptionBase = 0.0;
const float mieScatteringBase = 3.996;
const float mieAbsorptionBase = 4.4;
const vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, .085);

float safeAcos(float x) 
{
    return acos(clamp(x, -1.0, 1.0));
}

vec3 getSphericalDir(float theta, float phi)
{
     float cosPhi = cos(phi);
     float sinPhi = sin(phi);
     float cosTheta = cos(theta);
     float sinTheta = sin(theta);
     return vec3(sinPhi*sinTheta, cosPhi, sinPhi*cosTheta);
}

//  Intersecci贸n Rayo-Esfera (Optimizado)
float rayIntersectSphere(vec3 ro, vec3 rd, float radius) 
{
    float b = dot(ro, rd);
    float c = dot(ro, ro) - radius * radius;
    float delta = b * b - c;
    if (delta < 0.0) return -1.0; // No hay intersecci贸n

    float sqrtDelta = sqrt(delta);
    float t1 = -b - sqrtDelta;
    float t2 = -b + sqrtDelta;

    if (t1 > 0.0) return t1; // Primer impacto
    if (t2 > 0.0) return t2; // Segundo impacto (si el origen est谩 dentro)
    return -1.0; // No hay intersecci贸n v谩lida
}

float getMiePhase(float cosTheta) 
{
    const float g = 0.8;
    const float scale = 3.0/(8.0*PI);
    
    float num = (1.0-g*g)*(1.0+cosTheta*cosTheta);
    float denom = (2.0+g*g)*pow((1.0 + g*g - 2.0*g*cosTheta), 1.5);
    
    return scale*num/denom;
}

float getRayleighPhase(float cosTheta) 
{
    const float k = 3.0/(16.0*PI);
    return k*(1.0+cosTheta*cosTheta);
}

void getScatteringValues(vec3 pos, out vec3 rayleighScattering, out float mieScattering, out vec3 extinction) 
{
    float altitudeKM = (length(pos)-groundRadiusMM)*1000.0;
    // Note: Paper gets these switched up.
    float rayleighDensity = exp(-altitudeKM/8.0);
    float mieDensity = exp(-altitudeKM/1.2);
    
    rayleighScattering = rayleighScatteringBase*rayleighDensity;
    float rayleighAbsorption = rayleighAbsorptionBase*rayleighDensity;
    
    mieScattering = mieScatteringBase*mieDensity;
    float mieAbsorption = mieAbsorptionBase*mieDensity;
    
    vec3 ozoneAbsorption = ozoneAbsorptionBase*max(0.0, 1.0 - abs(altitudeKM-25.0)/15.0);
    
    extinction = rayleighScattering + rayleighAbsorption + mieScattering + mieAbsorption + ozoneAbsorption;
}

vec3 getValFromTLUT(vec3 pos, vec3 sunDir)
{
    float height = length(pos);
    vec3 up = pos / height;
    float sunCosZenithAngle = dot(sunDir, up);
    vec2 bufferRes = vec2(imageSize(InputImage));
    
    vec2 uv = vec2(
        bufferRes.x * clamp(0.5 + 0.5 * sunCosZenithAngle, 0.0, 1.0),
        bufferRes.y * max(0.0, min(1.0, (height - groundRadiusMM) / (atmosphereRadiusMM - groundRadiusMM)))
    );
    uv /= bufferRes;
    
    ivec2 texelCoords = ivec2(uv * bufferRes);
    return imageLoad(InputImage, texelCoords).rgb;
}

void getMulScattValues(vec3 pos, vec3 sunDir, out vec3 lumTotal, out vec3 fms) 
{
    lumTotal = vec3(0.0);
    fms = vec3(0.0);
    
    float invSamples = 1.0/float(sqrtSamples*sqrtSamples);
    for (int i = 0; i < sqrtSamples; i++) {
        for (int j = 0; j < sqrtSamples; j++) {
            // This integral is symmetric about theta = 0 (or theta = PI), so we
            // only need to integrate from zero to PI, not zero to 2*PI.
            float theta = PI * (float(i) + 0.5) / float(sqrtSamples);
            float phi = safeAcos(clamp(1.0 - 2.0 * (float(j) + 0.5) / float(sqrtSamples), -1.0, 1.0));
            vec3 rayDir = getSphericalDir(theta, phi);
            
            float atmoDist = rayIntersectSphere(pos, rayDir, atmosphereRadiusMM);
            float groundDist = rayIntersectSphere(pos, rayDir, groundRadiusMM);
            float tMax = atmoDist;
            if (groundDist > 0.0) {
                tMax = groundDist;
            }
            
            float cosTheta = dot(rayDir, sunDir);
    
            float miePhaseValue = getMiePhase(cosTheta);
            float rayleighPhaseValue = getRayleighPhase(-cosTheta);
            
            vec3 lum = vec3(0.0), lumFactor = vec3(0.0), transmittance = vec3(1.0);
            float t = 0.0;
            for (float stepI = 0.0; stepI < mulScattSteps; stepI += 1.0) {
                float newT = ((stepI + 0.3)/mulScattSteps)*tMax;
                float dt = newT - t;
                t = newT;

                vec3 newPos = pos + t*rayDir;

                vec3 rayleighScattering, extinction;
                float mieScattering;
                getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

                vec3 sampleTransmittance = exp(-dt*extinction);
                
                // Integrate within each segment.
                vec3 scatteringNoPhase = rayleighScattering + mieScattering;
                vec3 scatteringF = (scatteringNoPhase - scatteringNoPhase * sampleTransmittance) / extinction;
                lumFactor += transmittance*scatteringF;
                
                // This is slightly different from the paper, but I think the paper has a mistake?
                // In equation (6), I think S(x,w_s) should be S(x-tv,w_s).
                vec3 sunTransmittance = getValFromTLUT(newPos, sunDir);

                vec3 rayleighInScattering = rayleighScattering*rayleighPhaseValue;
                float mieInScattering = mieScattering*miePhaseValue;
                vec3 inScattering = (rayleighInScattering + mieInScattering)*sunTransmittance;

                // Integrated scattering within path segment.
                vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;

                lum += scatteringIntegral*transmittance;
                transmittance *= sampleTransmittance;
            }
            
            if (groundDist > 0.0) 
            {
                vec3 hitPos = pos + groundDist*rayDir;
                if (dot(pos, sunDir) > 0.0) {
                    hitPos = normalize(hitPos)*groundRadiusMM;
                    lum += transmittance*groundAlbedo*getValFromTLUT(hitPos, sunDir);
                }
            }
            
            fms += lumFactor;//*invSamples;
            lumTotal += lum*invSamples;
        }
    }
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(texel) / vec2(imageSize(OutputImage));
   
    float sunCosTheta = mix(-1.0, 1.0, uv.x);
    float sunTheta = safeAcos(sunCosTheta);
    float height = mix(groundRadiusMM, atmosphereRadiusMM, max(uv.y, 1e-6));
    
    vec3 pos = vec3(0.0, height, 0.0); 
    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));
    
    vec3 lum, f_ms;
    getMulScattValues(pos, sunDir, lum, f_ms);
    
    // Equation 10 from the paper.
    vec3 psi = lum / (1.0 - f_ms); 

    imageStore(OutputImage, texel, vec4(psi, 1.0));
}