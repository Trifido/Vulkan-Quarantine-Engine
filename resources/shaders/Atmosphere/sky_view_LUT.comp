#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba16f) uniform image2D InputImage;
layout(binding = 1, rgba16f) uniform image2D InputImage_2;
layout(binding = 2, rgba16f) uniform image2D OutputImage;

const int numScatteringSteps = 32;
const float PI = 3.14159265358;

// Unidades en Megametros (MM)
const float groundRadiusMM = 6.360;
const float atmosphereRadiusMM = 6.460;

// Coeficientes de dispersión y absorción por MM
const vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1);
const float rayleighAbsorptionBase = 0.0;
const float mieScatteringBase = 3.996;
const float mieAbsorptionBase = 4.4;
const vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, .085);

float getMiePhase(float cosTheta) 
{
    const float g = 0.8;
    const float scale = 3.0/(8.0*PI);
    
    float num = (1.0-g*g)*(1.0+cosTheta*cosTheta);
    float denom = (2.0+g*g)*pow((1.0 + g*g - 2.0*g*cosTheta), 1.5);
    
    return scale*num/denom;
}

float getRayleighPhase(float cosTheta) 
{
    const float k = 3.0/(16.0*PI);
    return k*(1.0+cosTheta*cosTheta);
}

float safeAcos(float x) 
{
    return acos(clamp(x, -1.0, 1.0));
}

// 🔹 Intersección Rayo-Esfera (Optimizado)
float rayIntersectSphere(vec3 ro, vec3 rd, float radius) 
{
    float b = dot(ro, rd);
    float c = dot(ro, ro) - radius * radius;
    float delta = b * b - c;
    if (delta < 0.0) return -1.0; // No hay intersección

    float sqrtDelta = sqrt(delta);
    float t1 = -b - sqrtDelta;
    float t2 = -b + sqrtDelta;

    if (t1 > 0.0) return t1; // Primer impacto
    if (t2 > 0.0) return t2; // Segundo impacto (si el origen está dentro)
    return -1.0; // No hay intersección válida
}

vec3 getValFromTLUT(vec3 pos, vec3 sunDir)
{
    float height = length(pos);
    vec3 up = pos / height;
    float sunCosZenithAngle = dot(sunDir, up);
    vec2 bufferRes = vec2(imageSize(InputImage));
    
    vec2 uv = vec2(
        bufferRes.x * clamp(0.5 + 0.5 * sunCosZenithAngle, 0.0, 1.0),
        bufferRes.y * max(0.0, min(1.0, (height - groundRadiusMM) / (atmosphereRadiusMM - groundRadiusMM)))
    );
    uv /= bufferRes;
    
    ivec2 texelCoords = ivec2(uv * bufferRes);
    return imageLoad(InputImage, texelCoords).rgb;
}

vec3 getValFromMultiScattLUT(vec3 pos, vec3 sunDir)
{
    float height = length(pos);
    vec3 up = pos / height;
	float sunCosZenithAngle = dot(sunDir, up);
    vec2 bufferRes = vec2(imageSize(InputImage));
    
    vec2 uv = vec2(
        bufferRes.x * clamp(0.5 + 0.5 * sunCosZenithAngle, 0.0, 1.0),
        bufferRes.y * max(0.0, min(1.0, (height - groundRadiusMM) / (atmosphereRadiusMM - groundRadiusMM)))
    );
    uv /= bufferRes;
    ivec2 texelCoords = ivec2(uv * bufferRes);
    return imageLoad(InputImage_2, texelCoords).rgb;
}

void getScatteringValues(vec3 pos, out vec3 rayleighScattering, out float mieScattering, out vec3 extinction) 
{
    float altitudeKM = (length(pos)-groundRadiusMM)*1000.0;
    // Note: Paper gets these switched up.
    float rayleighDensity = exp(-altitudeKM/8.0);
    float mieDensity = exp(-altitudeKM/1.2);
    
    rayleighScattering = rayleighScatteringBase*rayleighDensity;
    float rayleighAbsorption = rayleighAbsorptionBase*rayleighDensity;
    
    mieScattering = mieScatteringBase*mieDensity;
    float mieAbsorption = mieAbsorptionBase*mieDensity;
    
    vec3 ozoneAbsorption = ozoneAbsorptionBase*max(0.0, 1.0 - abs(altitudeKM-25.0)/15.0);
    
    extinction = rayleighScattering + rayleighAbsorption + mieScattering + mieAbsorption + ozoneAbsorption;
}

vec3 raymarchScattering(vec3 pos, vec3 rayDir, vec3 sunDir, float tMax) {
    float cosTheta = dot(rayDir, sunDir);
    float miePhaseValue = getMiePhase(cosTheta);
    float rayleighPhaseValue = getRayleighPhase(-cosTheta);
    
    vec3 lum = vec3(0.0);
    vec3 transmittance = vec3(1.0);
    float t = 0.0;
    
    for (int i = 0; i < numScatteringSteps; i++)
    {
        float newT = ((float(i) + 0.3) / float(numScatteringSteps)) * tMax;
        float dt = newT - t;
        t = newT;
        
        vec3 newPos = pos + t * rayDir;
        
        vec3 rayleighScattering, extinction;
        float mieScattering;
        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);
        
        vec3 sampleTransmittance = exp(-dt * extinction);
        vec3 sunTransmittance = getValFromTLUT(newPos, sunDir);
        vec3 psiMS = getValFromMultiScattLUT(newPos, sunDir);
        
        vec3 rayleighInScattering = rayleighScattering * (rayleighPhaseValue * sunTransmittance + psiMS);
        vec3 mieInScattering = mieScattering * (miePhaseValue * sunTransmittance + psiMS);
        vec3 inScattering = rayleighInScattering + mieInScattering;
        
        vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;
        lum += scatteringIntegral * transmittance;
        
        transmittance *= sampleTransmittance;
    }
    return lum;
}

const vec3 viewPos = vec3(0.0, groundRadiusMM + 0.0002, 0.0);

float getSunAltitude(float time)
{
    const float periodSec = 120.0;
    const float halfPeriod = periodSec / 2.0;
    const float sunriseShift = 0.1;
    float cyclePoint = (1.0 - abs((mod(time,periodSec)-halfPeriod)/halfPeriod));
    cyclePoint = (cyclePoint*(1.0+sunriseShift))-sunriseShift;
    return (0.5*PI)*cyclePoint;
}

vec3 getSunDir()
{
    float altitude = getSunAltitude(10.5);
    return normalize(vec3(0.0, sin(altitude), -cos(altitude)));
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(OutputImage);
    
    if (texelCoord.x >= resolution.x || texelCoord.y >= resolution.y) {
        return;
    }
    
    vec2 uv = vec2(texelCoord) / vec2(resolution);
    
    float azimuthAngle = (uv.x - 0.5) * 2.0 * PI;
    float adjV = (uv.y < 0.5) ? -(1.0 - 2.0 * uv.y) * (1.0 - 2.0 * uv.y) : (2.0 * uv.y - 1.0) * (2.0 * uv.y - 1.0);
    
    float height = length(viewPos);
    vec3 up = viewPos / height;
    float horizonAngle = safeAcos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height) - 0.5 * PI;
    float altitudeAngle = adjV * 0.5 * PI - horizonAngle;
    
    float cosAltitude = cos(altitudeAngle);
    vec3 rayDir = vec3(cosAltitude * sin(azimuthAngle), sin(altitudeAngle), -cosAltitude * cos(azimuthAngle));
    
    float sunAltitude = (0.5 * PI) - acos(dot(getSunDir(), up));
    vec3 sunDir = vec3(0.0, sin(sunAltitude), -cos(sunAltitude));
    
    float atmoDist = rayIntersectSphere(viewPos, rayDir, atmosphereRadiusMM);
    float groundDist = rayIntersectSphere(viewPos, rayDir, groundRadiusMM);
    float tMax = (groundDist < 0.0) ? atmoDist : groundDist;
    
    vec3 lum = raymarchScattering(viewPos, rayDir, sunDir, tMax);
    imageStore(OutputImage, texelCoord, vec4(lum, 1.0));
}