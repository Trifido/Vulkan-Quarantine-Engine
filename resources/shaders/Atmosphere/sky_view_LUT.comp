#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba16f) uniform image2D InputImage;
layout(binding = 1, rgba16f) uniform image2D InputImage_2;
layout(binding = 2, rgba16f) uniform image2D OutputImage;

layout(set = 0, binding = 3) uniform CameraUniform
{
	mat4 view;
	mat4 proj;
	mat4 viewproj;
    vec4 position;
    vec4 frustumPlanes[6];
} cameraData;

const float PI = 3.14159265358;

const int numScatteringSteps = 32;
// Unidades en Megametros (MM)
const float PlanetRadius = 6.360;
const float AtmosphereRadius = 6.460;

// Coeficientes de dispersión y absorción por MM
const vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1);
const float mieScatteringBase = 3.996;
const float mieAbsorptionBase = 4.4;
const float asymmetryMie = 0.8;
float  hDensityRayleigh = 8;
float  hDensityMie  = 1.2;
const vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, 0.085);
float  ozoneCenterHeight = 25;
float  ozoneThickness   = 30;


int RAY_MARCH_STEP_COUNT = 256;

bool EnableMultiScattering = true;

//SUN
const vec3 SunIntensity = vec3(10.0, 10.0, 10.0);
const float sunRadX = 0.0;
const float sunRadY = -2.024582;

vec3 getTransmittance(float h, float theta)
{
    ivec2 textureSize = imageSize(InputImage);
    float u = h / (AtmosphereRadius - PlanetRadius);
    float v = 0.5 + 0.5 * sin(theta);
    ivec2 pixelCoords = ivec2(u * float(textureSize.x - 1), v * float(textureSize.y - 1));

    return imageLoad(InputImage, pixelCoords).rgb;
}

void getSigmaST(float h, out vec3 sigmaS, out vec3 sigmaT)
{
    vec3 rayleigh = rayleighScatteringBase * exp(-h / hDensityRayleigh);

    float mieDensity = exp(-h / hDensityMie);
    float mieS = mieScatteringBase * mieDensity;
    float mieT = (mieScatteringBase + mieAbsorptionBase) * mieDensity;

    vec3 ozone = ozoneAbsorptionBase * max(0.0, 1.0 - 0.5 * abs(h - ozoneCenterHeight) / ozoneThickness);

    sigmaS = rayleigh + mieS;
    sigmaT = rayleigh + mieT + ozone;
}

bool hasIntersectionWithSphere(vec3 o, vec3 d, float R)
{
    float A = dot(d, d);
    float B = 2.0 * dot(o, d);
    float C = dot(o, o) - R * R;
    float delta = B * B - 4.0 * A * C;
    return (delta >= 0.0) && ((C <= 0.0) || (B <= 0.0));
}

bool findClosestIntersectionWithCircle(
    vec2 o, vec2 d, float R, out float t)
{
    float A = dot(d, d);
    float B = 2 * dot(o, d);
    float C = dot(o, o) - R * R;
    float delta = B * B - 4 * A * C;
    if(delta < 0)
        return false;
    t = (-B + (C <= 0 ? sqrt(delta) : -sqrt(delta))) / (2 * A);
    return (C <= 0) || (B <= 0);
}

vec3 evalPhaseFunction(float h, float u)
{
    vec3 sRayleigh = rayleighScatteringBase * exp(-h / hDensityRayleigh);
    float sMie = mieScatteringBase * exp(-h / hDensityMie);
    vec3 s = sRayleigh + sMie;

    float g = asymmetryMie, g2 = g * g, u2 = u * u;
    float pRayleigh = 3.0 / (16.0 * PI) * (1.0 + u2);

    float m = 1.0 + g2 - 2.0 * g * u;
    float pMie = 3.0 / (8.0 * PI) * (1.0 - g2) * (1.0 + u2) / ((2.0 + g2) * m * sqrt(m));

    vec3 result;
    result.x = s.x > 0.0 ? (pRayleigh * sRayleigh.x + pMie * sMie) / s.x : 0.0;
    result.y = s.y > 0.0 ? (pRayleigh * sRayleigh.y + pMie * sMie) / s.y : 0.0;
    result.z = s.z > 0.0 ? (pRayleigh * sRayleigh.z + pMie * sMie) / s.z : 0.0;
    return result;
}

void marchStep(
    float phaseU, vec3 ori, vec3 dir, float thisT, float nextT,
    inout vec3 sumSigmaT, inout vec3 inScattering)
{
    float  midT = 0.5 * (thisT + nextT);
    vec3 posR = vec3(0, ori.y + PlanetRadius, 0) + dir * midT;
    float  h    = length(posR) - PlanetRadius;

    vec3 sigmaS, sigmaT;
    getSigmaST(h, sigmaS, sigmaT);

    vec3 deltaSumSigmaT = (nextT - thisT) * sigmaT;
    vec3 eyeTrans = exp(-sumSigmaT - 0.5 * deltaSumSigmaT);

    vec3 SunDirection = vec3(cos(sunRadX) * cos(sunRadY), sin(sunRadY), sin(sunRadX) * cos(sunRadY));
    SunDirection = normalize(SunDirection);

    float sunTheta = PI / 2.0 - acos(dot(-SunDirection, normalize(posR)));

    if(!hasIntersectionWithSphere(
        posR, -SunDirection, PlanetRadius))
    {
        vec3 rho = evalPhaseFunction(h, phaseU);
        vec3 sunTrans = getTransmittance(h, sunTheta);

        inScattering += (nextT - thisT) * eyeTrans * sigmaS * rho * sunTrans;
    }

    if(EnableMultiScattering)
    {
        ivec2 textureSize = imageSize(InputImage_2);
        float tx = h / (AtmosphereRadius - PlanetRadius);
        float ty = 0.5 + 0.5 * sin(sunTheta);

        ivec2 pixelCoords = ivec2(tx * float(textureSize.x - 1), ty * float(textureSize.y - 1));
        vec3 ms = imageLoad(InputImage_2, pixelCoords).rgb;

        inScattering += (nextT - thisT) * eyeTrans * sigmaS * ms;
    }

    sumSigmaT += deltaSumSigmaT;
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(OutputImage);
    
    if (texelCoord.x >= resolution.x || texelCoord.y >= resolution.y) {
        return;
    }
    
    vec2 uv = vec2(texelCoord) / vec2(resolution);

    float phi = 2 * PI * uv.x;
    float vm = 2 * uv.y - 1;
    float theta = sign(vm) * (PI / 2) * vm * vm;
    float sinTheta = sin(theta), cosTheta = cos(theta);

    vec3 ori = cameraData.position.xyz;
    vec3 dir = vec3(cos(phi) * cosTheta, sinTheta, sin(phi) * cosTheta);

    vec2 planetOri = vec2(0, ori.y + PlanetRadius);
    vec2 planetDir = vec2(cosTheta, sinTheta);

    // find end point
    float endT = 0;
    if(!findClosestIntersectionWithCircle(planetOri, planetDir, PlanetRadius, endT))
    {
        findClosestIntersectionWithCircle(planetOri, planetDir, AtmosphereRadius, endT);
    }

    vec3 SunDirection = vec3(cos(sunRadX) * cos(sunRadY), sin(sunRadY), sin(sunRadX) * cos(sunRadY));
    SunDirection = normalize(SunDirection);
    // phase function input

    float phaseU = dot(SunDirection, -dir);

    // ray march

    float t = 0;
    vec3 inScatter = vec3(0, 0, 0);
    vec3 sumSigmaT = vec3(0, 0, 0);

    float dt = (endT - t) / RAY_MARCH_STEP_COUNT;
    for(int i = 0; i < RAY_MARCH_STEP_COUNT; ++i)
    {
        float nextT = t + dt;
        marchStep(phaseU, ori, dir, t, nextT, sumSigmaT, inScatter);
        t = nextT;
    }

    imageStore(OutputImage, texelCoord, vec4(inScatter * SunIntensity, 1.0));
}